# etc. HTTPS 

### 사전지식
- 대칭키 : 암호화 할때와 복호화 할때 사용하는 KEY 가 동일하다.  
  (1) 데이터 -> ( KEY ) -> 암호화된 데이터   
  (2) 암호화된 데이터 -> ( KEY ) -> 데이터   
  -> 성능적으로 공개키 방식보다 유리  
  -> 단점: 그래서 KEY 는 어떻게 전달할건데?  
  > 비밀쪽지 받는쪽: 야 Key 로 암호화해서 보내!  
  > 비밀쪽지 보내는쪽: 오케이 Key 로 암호화해서 보낼게!  
  > 나쁜놈: Key 로 복호화 하면 되는건가? 오!! 이런 비밀얘기를 하고 있었군 
    
   
- 공개키 : A키로 암호화된 데이터는 B키로 복호화 / B키로 암호화된 데이터는 A키로 복호화 하는 방식  
  (1) 데이터 -> (public key) -> 암호화된 데이터  
  (2) 암호화된 데이터 -> (private key) -> 데이터  
  -> 단점: 성능적으로 대칭키 방식보다 불리  
  > 비밀쪽지를 받는쪽: 야! public key 로 암호화해서 보내  
  비밀쪽지를 보내는쪽: 오케이 public key 로 암호화해서 보낼게!  
  나쁜놈: public key 로 복호화 하면 되는건가? 뭐야 이거 public key 로 복호화가 안되네?
   



## HTTPS? 
HTTPS 는 간단히 말해 HTTP 에 보안을 얹은 프로토콜이라고 생각하면 된다.  
HTTPS 에서 'S' 는 Over the Secure 을 의미하고, HTTP 통신을 할 때 주고받는 데이터를 암호화된 통신채널로 주고받음으로써 
보안을 강화한 프로토콜이다.

### HTTPS & SSL 
HTTPS 가 암호화된 통신채널을 사용한다 하였는데, 암호화된 통신채널 규약이 바로 SSL 이다.  
![계층구조]()  
위의 그림에서 알 수 있듯이, HTTP 프로토콜을 SSL 프로토콜로 감싼다면 그게 바로 HTTPS 프로토콜이라고 할 수 있겠다.

> TSL? SSL을 검색하면 항상 TSL이 같이 검색된다. Netscape 에 의해 개발된 프로토콜이 SSL 이고 
> 이를 바탕으로 IETF(국제 인터넷 표준화 기구)가 표준화한 프로토콜이 TSL 이다.

### SSL 인증서
신뢰할 만한 서버인지를 보장 해주기 위해 제3자(CA)가 발급하는 전자화된 문서이다.
> 클라이언트가 되는 브라우저가 자신의 CA 들을 지정한다. (즉, 누구나 CA가 될 순 있지만 브라우저가 인정하는 CA가 될 순 없다.) 


## SSL이 안전하면서 성능적으로 괜찮은 이유 
> 네트워크 통신 과정 : HandShake -> 세션 -> 세션종료 

서버는 자신이 신뢰할 만한 서버임을 보장하기 위해 CA에게 인증을 받고 SSL 인증서를 획득한다.

1. HandShake 
   1) Client Hello : 클라이언트가 서버에 접속할 떄 
    주고받는 정보  
      - 클라이언트 측에서 생성한 랜덤 데이터 
      - 클라이언트가 지원하는 암호화 방식 
      - 세션 아이디 
    2) Server Hello : Client Hello 에 대한 서버의 응답
    주고받는 정보 
       - 서버 측에서 생성한 랜덤 데이터 
       - 서버가 선택한 암호화 방식 
       - SSL 인증서 
    
 
2. 클라이언트는 자신이 신뢰하는 CA가 발급하는 SSL 인증서임을 확인하고 HandShake 과정에서 만들어진 클라이언트/서버 측 랜덤 데이터를 조합해 **pre master secret** 를 생성한다.

 
3. 생성한 **pre master secret** 을 SSL 인증서에 적혀있는 public key 로 암호화 하여 서버에 전달한다.

(pre master secret 를 복호화 할 수 있는 곳은 private key 를 가진 서버 뿐이다.)


4. 서버와 클라이언트는 pre master secret 을 기반으로 master secret 값을 만들고, master secret 을 기반으로 session key 를 만들어
handshake 이후에 실제로 통신이 일어날때 사용하는 대칭키가 된다. 
   

